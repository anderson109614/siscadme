<?php

function getClaveSercreta(){
    $secret='clave secreta';
    return $secret;
 }
 function getkey(){
    $secret='sfloserv2021@';
    return $secret;
 }
function jwtCreate($user,$dat){
    $arr = array('alg' => 'HS256', 'typ' => 'JWT');
    $arr2 = json_encode($arr);
    $encoded_header = base64_encode($arr2);
    $secret_key = getClaveSercreta();

    $arr3 = array( 'usuario' => $user,'date'=>$dat,'timeZone'=>date_default_timezone_get());
    $arr33 = json_encode($arr3);
    $encoded_payload = base64_encode($arr33);
    $header_payload = $encoded_header . '.' . $encoded_payload;

    $signature = base64_encode(hash_hmac('sha256', $header_payload, $secret_key, true));

    $jwt_token = $header_payload . '.' . $signature;

    return $jwt_token;
}
function jwtVali($tok){
    $secret_key =  getClaveSercreta();
    $recievedJwt = $tok;

    // Split a string by '.' 
    $jwt_values = explode('.', $recievedJwt);

    // extracting the signature from the original JWT   
    //extrayendo la firma del JWT original
    $recieved_signature = $jwt_values[2];

    // concatenating the first two arguments of the $jwt_values array, representing the header and the payload 
    //concatenando los dos primeros argumentos de la matriz $ jwt_values, que representan el encabezado y la carga útil
    $recievedHeaderAndPayload = $jwt_values[0] . '.' . $jwt_values[1];

    // creating the Base 64 encoded new signature generated by applying the HMAC method to the concatenated header and payload values
    //Crear la nueva firma codificada en Base 64 generada mediante la aplicación del método HMAC al encabezado concatenado y los valores de carga útil.
    $resultedsignature = base64_encode(hash_hmac('sha256', $recievedHeaderAndPayload, $secret_key, true));

    // checking if the created signature is equal to the received signature
    if($resultedsignature == $recieved_signature) {

        // If everything worked fine, if the signature is ok and the payload was not modified you should get a success message
        return true;
    } else {

        return false;

    }
}
function getInfo($tok){
    $secret_key = 'clave secreta';
    $recievedJwt = $tok;
    $jwt_values = explode('.', $recievedJwt);
    $body = $jwt_values[1];
    return base64_decode($body);
    

}
function encrypt($string,$isString)
{

        if(false){
            $key=getkey();
            $ivLength = openssl_cipher_iv_length('AES-256-CBC');
            $iv = openssl_random_pseudo_bytes($ivLength);
 
            $salt = openssl_random_pseudo_bytes(256);
            $iterations = 999;
            $hashKey = hash_pbkdf2('sha512', $key, $salt, $iterations, 64);
        
            if(!$isString){
                $string= json_encode($string);
            }
            $encryptedString = openssl_encrypt($string, 'AES-256-CBC', hex2bin($hashKey), OPENSSL_RAW_DATA, $iv);

            $encryptedString = base64_encode($encryptedString);
            unset($hashKey);

            $output = ['ciphertext' => $encryptedString, 'iv' => bin2hex($iv), 'salt' => bin2hex($salt), 'iterations' => $iterations];
            unset($encryptedString, $iterations, $iv, $ivLength, $salt);

            return base64_encode(json_encode($output));
        }else{
            return $string;
        }
        
}
function decrypt($encryptedString)
{
    if(true){
        $key=getkey();
        $json = json_decode(base64_decode($encryptedString), true);

        try {
            $salt = hex2bin($json["salt"]);
            $iv = hex2bin($json["iv"]);
        } catch (Exception $e) {
            return null;
        }

        $cipherText = base64_decode($json['ciphertext']);

        $iterations = intval(abs($json['iterations']));
        if ($iterations <= 0) {
            $iterations = 999;
        }
        $hashKey = hash_pbkdf2('sha512', $key, $salt, $iterations, 64);
        unset($iterations, $json, $salt);

        $decrypted= openssl_decrypt($cipherText , 'AES-256-CBC', hex2bin($hashKey), OPENSSL_RAW_DATA, $iv);
        unset($cipherText, $hashKey, $iv);

        return $decrypted;
    }else{
        return $encryptedString;
    }
    
}


?>
